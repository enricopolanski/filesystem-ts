import * as A from "fp-ts/Array";
import * as E from "fp-ts/Either";
import * as TE from "fp-ts/TaskEither";
import * as T from "fp-ts/Task";
import { promises, Dirent, Stats } from "fs";
import { flow, identity, pipe } from "fp-ts/lib/function";
import {
  NoEntity,
  NoEntityDecoder,
  NotADirectory,
  NotADirectoryDecoder,
  NotEmptyDirectory,
  NotEmptyDirectoryDecoder,
  orUnknownError,
  unknownError,
  UnknownError,
} from "../errors";
import { Entity } from "../entities";
import { fileFromDirent, isFile } from "../file";
import { isSymLink, symLinkFromDirent } from "../symlink";
import { resolve } from "path";
import * as D from "io-ts/Decoder";
import { basename, sep } from "path";
import { tmpdir } from "os";

export interface Directory {
  type: "Directory";
  name: string;
  path: string;
  absolutePath: string;
}

export const DirectoryDecoder: D.Decoder<unknown, Directory> = D.struct({
  type: D.literal("Directory"),
  name: D.string,
  path: D.string,
  absolutePath: D.string,
});

const _isDirectory = (dirent: Dirent): boolean => dirent.isDirectory();

export const directoryOf: (pathInfo: {
  path: string;
  absolutePath: string;
}) => (name: string) => Directory = (pathInfo) => (name) => ({
  type: "Directory",
  name: name,
  path: pathInfo.path,
  absolutePath: pathInfo.absolutePath,
});

const fsPromiseToTE: <A, B>(
  f: (a: A) => Promise<B>
) => (a: A) => TE.TaskEither<unknown, B> = (f) => TE.tryCatchK(f, identity);

const getName: (dirent: Dirent) => string = (dirent) => dirent.name;

const _readDir: (s: string) => Promise<Dirent[]> = (s: string) =>
  promises.readdir(s, { withFileTypes: true });

const readDir: (s: string) => TE.TaskEither<unknown, Dirent[]> = fsPromiseToTE(
  _readDir
);

const _mkdtemp = (prefix: string) => promises.mkdtemp(tmpdir() + sep + prefix);

const mkdtemp = fsPromiseToTE(_mkdtemp);

const decodeListDirectoryError = pipe(
  D.union(NoEntityDecoder, NotADirectoryDecoder),
  orUnknownError
);

const getMetadataError: (
  i: unknown
) => MetadataError = decodeListDirectoryError;

type ListDirectoryError = NoEntity | NotADirectory | UnknownError;
type MetadataError = ListDirectoryError;

/**
 * Returns a `Task` with `Either` a list of all `Entity`s in `dir` or one of the following errors:
 * - `NoEntity`: given `dir` does not exist
 * - `UnknownError`: WIP
 */
export const listDirectory = (
  s: string
): TE.TaskEither<ListDirectoryError, Entity[]> =>
  pipe(
    TE.Do,
    TE.bind("absolutePath", () => TE.right(resolve(s))),
    TE.bind("path", () => TE.right(s)),
    TE.chain((info) =>
      pipe(
        readDir(s),
        TE.mapLeft(decodeListDirectoryError),
        TE.map((dirents) => ({
          directories: pipe(
            dirents,
            A.filter(_isDirectory),
            A.map(flow(getName, directoryOf(info)))
          ),
          files: pipe(dirents, A.filter(isFile), A.map(fileFromDirent(info))),
          symLinks: pipe(
            dirents,
            A.filter(isSymLink),
            A.map(symLinkFromDirent(info))
          ),
        })),
        TE.map((directory) => [
          ...directory.directories,
          ...directory.files,
          ...directory.symLinks,
        ])
      )
    )
  );

/**
 * Creates a temporary directory inside the OS' default temporary directory.
 * The `prefix` will determine the first part of the directory name,
 * the rest being randomly generated by the OS.
 */
export const createTemporaryDirectory: (
  prefix: string
) => TE.TaskEither<UnknownError, Directory> = (prefix) =>
  pipe(
    mkdtemp(prefix),
    TE.map((path) =>
      directoryOf({ path: path, absolutePath: path })(basename(path))
    ),
    TE.mapLeft(unknownError)
  );

const _stat = (s: string) => promises.stat(s, { bigint: false });

const stat: (a: string) => TE.TaskEither<unknown, Stats> = fsPromiseToTE(_stat);

export const getMetadata: (
  a: string
) => TE.TaskEither<MetadataError, Stats> = flow(
  stat,
  TE.mapLeft(getMetadataError)
);

const getDirectory = (s: string) =>
  pipe(
    getMetadata(s),
    TE.chain((stat) =>
      stat.isDirectory()
        ? TE.right(stat)
        : TE.left({
            type: "ENOTDIR" as "ENOTDIR",
            path: s,
            syscall: "UNKNOWN",
            message: s + " is NOT a Directory",
          })
    )
  );

/**
 * DANGEROUS: DON'T USE
 */
export const isDirectory: (s: string) => T.Task<boolean> = flow(getDirectory, T.map(E.isRight));

const _mkdir = (s: string) => promises.mkdir(s);

const mkdir = fsPromiseToTE(_mkdir);

type CreateDirectoryError = UnknownError;

/**
 * Creates a new empty directory at the provided path `s
 */
export const createDirectory: (s: string) => TE.TaskEither<CreateDirectoryError, Directory> = s => pipe(mkdir(s), TE.mapLeft(unknownError), TE.map(() => ({
  type: "Directory",
  path: s,
  name: basename(s),
  absolutePath: s
})));

const _rmdir = (s: string) => promises.rmdir(s);
const rmdir = fsPromiseToTE(_rmdir);

const _rmdirRecursive = (s: string) => promises.rmdir(s, {recursive: true});
const rmdirReducursive = fsPromiseToTE(_rmdirRecursive);

type RemoveDirectoryError = NotEmptyDirectory | UnknownError;

const removeDirectoryError = pipe(NotEmptyDirectoryDecoder, orUnknownError);

export const removeDirectory: (s: string) => TE.TaskEither<RemoveDirectoryError, void> = flow(rmdir, TE.mapLeft(removeDirectoryError));

export const removeDirectoryRecursive : (s: string) => TE.TaskEither<RemoveDirectoryError, void> = flow(rmdirReducursive, TE.mapLeft(removeDirectoryError));

