import * as A from 'fp-ts/Array';
import { promises, Dirent } from 'fs';
import * as TE from 'fp-ts/TaskEither';
import { flow, identity, pipe } from 'fp-ts/lib/function';
import {
  NoEntity,
  NoEntityDecoder,
  NotADirectory,
  NotADirectoryDecoder,
  orUnknownError,
  unknownError,
  UnknownError,
} from '../errors';
import { Entity } from '../entities';
import { fileFromDirent, isFile } from '../file';
import { isSymLink, symLinkFromDirent } from '../symlink';
import { resolve } from 'path';
import * as D from 'io-ts/Decoder';
import { basename } from 'path';

export interface Directory {
  type: 'Directory';
  name: string;
  path: string;
  absolutePath: string;
}

export const DirectoryDecoder: D.Decoder<unknown, Directory> = D.struct({
  type: D.literal('Directory'),
  name: D.string,
  path: D.string,
  absolutePath: D.string,
});

export const isDirectory = (dirent: Dirent): boolean => dirent.isDirectory();

export const directoryFromDirent: (pathInfo: {
  path: string;
  absolutePath: string;
}) => (dirent: Dirent) => Directory = (pathInfo) => (dirent) => ({
  type: 'Directory',
  name: dirent.name,
  path: pathInfo.path,
  absolutePath: pathInfo.absolutePath,
});

const _readDir: (s: string) => Promise<Dirent[]> = (s: string) =>
  promises.readdir(s, { withFileTypes: true });

const readDir: (s: string) => TE.TaskEither<unknown, Dirent[]> = TE.tryCatchK(
  _readDir,
  identity
);

const _mkdtemp = (prefix: string) => promises.mkdtemp(prefix);

const mkdtemp = TE.tryCatchK(_mkdtemp, identity);

const decodeListDirectoryError = pipe(
  D.union(NoEntityDecoder, NotADirectoryDecoder),
  orUnknownError
);

/**
 * Returns a `Task` with `Either` a list of all `Entity`s in `dir` or one of the following errors:
 * - `NoEntity`: given `dir` does not exist
 * - `UnknownError`: WIP
 */
export const listDirectory = (
  dir: string
): TE.TaskEither<NoEntity | NotADirectory | UnknownError, Entity[]> =>
  pipe(
    TE.Do,
    TE.bind('absolutePath', () => TE.right(resolve(dir))),
    TE.bind('path', () => TE.right(dir)),
    TE.chain((info) =>
      pipe(
        readDir(dir),
        TE.mapLeft(decodeListDirectoryError),
        TE.map((dirents) => ({
          directories: pipe(
            dirents,
            A.filter(isDirectory),
            A.map(directoryFromDirent(info))
          ),
          files: pipe(dirents, A.filter(isFile), A.map(fileFromDirent(info))),
          symLinks: pipe(
            dirents,
            A.filter(isSymLink),
            A.map(symLinkFromDirent(info))
          ),
        })),
        TE.map((directory) => [
          ...directory.directories,
          ...directory.files,
          ...directory.symLinks,
        ])
      )
    )
  );

/**
 * Creates a temporary directory inside the OS' default temporary directory.
 * The `prefix` will determine the first part of the directory name,
 * the rest being randomly generated by the OS.
 */
export const createTemporaryDirectory: (
  prefix: string
) => TE.TaskEither<UnknownError, Directory> = (prefix) =>
  pipe(
    mkdtemp(prefix),
    TE.map((directoryPath) => ({
      type: 'Directory' as 'Directory',
      path: directoryPath,
      absolutePath: directoryPath,
      name: basename(directoryPath),
    })),
    TE.mapLeft(unknownError)
  );
